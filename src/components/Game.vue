<template>
<div style="position: relative; width: 100%; height: 100%;">
  <div style="width: 65%; height: 80%; top: 10%; left: 5%; position: absolute;">
    <div
      :class="['game-board', 'board-background-' + properties.boardSettings.background]"
      ref="board"
      panels="control">
    </div>
  </div>
  <div style="left: 75%; top: 10%; height: 80%; width: 25%; position: absolute;">
    <div>
      <h2>
        {{properties.title}}
      </h2>
    </div>
    <div v-html="properties.text"></div>
    <div>
      <button @click="board.editor.click(0, 0, false)">Pass</button>
    </div>
  </div>
  <div style="position: absolute; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.4);" v-if="over">
    <div style="position: absolute; left: 20%; top: 30%; width: 60%; height: 40%; background-color: #eeddbb; padding: 20px;">
      <div style="text-align: center; font-size: 24px; font-weight: bold;">
        Game Over
      </div>
      <div style="text-align: center; font-size: 32px; font-weight: bold;">
        {{over.winner}} wins!
      </div>
      <div style="text-align: center; font-size: 18px;">
        {{over.score}}
      </div>
      <button style="text-align: center;" @click="gameOverContinue">Continue</button>
    </div>
  </div>
</div>
</template>

<script>
import AI from '../classes/AI';

export default {
  props: ['properties', 'sceneConfig'],
  data () {
    return {
      userColor: -1,
      board: null,
      ai: null,
      over: null
    }
  },
  computed: {
    userColorLetter () {
      return (this.userColor === -1) ? 'B' : 'W';
    },
    opponentColorLetter () {
      return (this.userColor ===  1) ? 'B' : 'W';
    }
  },
  methods: {
    setupBoard () {
      this.$refs.board.innerHTML = this.properties.boardSettings.sgf;

      this.board = besogo.create(this.$refs.board, {
        panels: ['names'],
        tool: 'playWithoutUndo',
        nowheel: true,
        nokeys: true,
        customstones: this.properties.boardSettings.customstones
      })

      this.board.editor.setGameInfo("Human", "P" + this.userColorLetter);
      this.board.editor.setGameInfo("7k", this.userColorLetter + "R");

      this.board.editor.setGameInfo("GNUGo", "P" + this.opponentColorLetter);
      this.board.editor.setGameInfo(this.sceneConfig.aiSettings.level, this.opponentColorLetter + "R");

      this.ai = new AI(this.sceneConfig.aiSettings);

      if (this.userColor == 1) {
        this.playAIMove();
      }

      this.board.editor.addListener((data) => {
        if (
          data.treeChange &&
          this.board.editor.getCurrent().move.color == this.userColor
        ) {
          this.playAIMove();

        }
      });
    },
    gameOverContinue () {
      Promise.resolve(() => {
        if (this.over.score[0] == this.userColorLetter) {
          this.sceneConfig.onWin()
        } else if (this.over.score[0] == this.opponentColorLetter) {
          this.sceneConfig.onLose()
        }
      }).then(() => {
        window.GlobalConfig.scene.end();
      });
    },
    playAIMove () {
      // Prevent moves
      this.board.editor.setTool('none');

      this.ai.genMove(this.board).then((aiMove) => {
        // Play the move generated by the AI
        if (aiMove.response) {
          let move = this.ai.convertToXY(aiMove.response, this.board);
          this.board.editor.playMove(move.x, move.y)
        }

        if (aiMove.over) {
          aiMove.final_status.dead.forEach((coord) => {
            let move = this.ai.convertToXY(coord, this.board);
            this.board.editor.setMarkup(move.x, move.y, 4);
          });
          aiMove.final_status.white.forEach((coord) => {
            let move = this.ai.convertToXY(coord, this.board);
            this.board.editor.setMarkup(move.x, move.y, 51);
          });
          aiMove.final_status.black.forEach((coord) => {
            let move = this.ai.convertToXY(coord, this.board);
            this.board.editor.setMarkup(move.x, move.y, 52);
          });

          this.over = {};
          this.over.winner = aiMove.final_status.score[0];
          this.over.score = aiMove.final_status.score;
        } else {
          // Enable playing again
          this.board.editor.setTool('playWithoutUndo');
        }
      }).catch(() => {
        // Enable playing again
        this.board.editor.setTool('playWithoutUndo');
      });
    }
  },
  mounted () {
    if (this.properties.boardSettings.userColor) {
      this.userColor = this.properties.boardSettings.userColor;
    }

    this.$nextTick(() => {
      this.setupBoard()
    })
  },
  created () {
    window.GlobalConfig.vue = this;
  }
}
</script>

<style lang="scss">
  .game-board {
    width: 100% !important;
    height: 100% !important;
  }

  .game-board.besogo-container {
    background: inherit;
  }

  .board-background-water {
    .besogo-svg-board {
      fill: #6688cd;
    }
  }
</style>
